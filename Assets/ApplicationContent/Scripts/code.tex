\subsubsection*{EventMessageListener.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>A class that triggers events associated with a biofeedback device</para>
/// </summary>
public class EventMessageListener : MonoBehaviour
{
    /// <summary>
    /// <para>Event triggered when the connection status of the device changes</para>
    /// </summary>
    public event UnityAction<bool> ConnectionChanged;

    /// <summary>
    /// <para>Event triggered when a message is arrived from the device</para>
    /// </summary>
    public event UnityAction<string> MessageArrived;


    private const string MESSAGE_ARRIVED_PREFIX = "Message arrived: ";

    // Invoked when a line of data is received from the serial device.
    private void OnMessageArrived(string msg)
    {
        Debug.Log(MESSAGE_ARRIVED_PREFIX + msg);
        MessageArrived?.Invoke(msg);
    }

    // Invoked when a connect/disconnect event occurs. The parameter 'success'
    // will be 'true' upon connection, and 'false' upon disconnection or
    // failure to connect.
    private void OnConnectionEvent(bool success)
    {
        ConnectionChanged?.Invoke(success);
    }
}
\end{minted}
\subsubsection*{PulseReceiver.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>A component that requests, receives and processes the pulse from a biofeedback device</para>
/// If a biofeedback device is not available, this component may use placeholder
/// </summary>
[RequireComponent(typeof(EventMessageListener))]
public class PulseReceiver : MonoBehaviour
{
    /// <summary>
    /// <para>Event triggered when a heart rate value is received from a device or placeholder</para>
    /// </summary>
    public event UnityAction<int> PulseReceived;

    /// <summary>
    /// <para>Event triggered when heart rate acceleration is recalculated</para>
    /// </summary>
    public event UnityAction<float> AccelerationCalculated;

    private const string PULSE_PREFIX = "pulse=";
    private const string PULSE_REQUEST_MESSAGE = "1";
    private const int PULSE_NOT_RECEIVED = -1;

    [Tooltip("Whether to write debug information to the console")] 
    [SerializeField] private bool _debug = false;

    [SerializeField] private SerialController _serialController;

    [Tooltip("Frequency of requesting a heart rate value from the device")] [Min(0.000001f)] 
    [SerializeField] private float _pollingRateSeconds;

    [Tooltip("Device polling period for which heart rate acceleration will be recalculated")] [Min(1)] 
    [SerializeField] private int _recalculatingCyclePeriod;

    [SerializeField] private bool _usePlaceholder;
    [Range(1, 150)] [SerializeField] private int _placeholderPulse;
    [SerializeField] private float _placeholderAcceleration;

    private bool connected = false;
    private float timeSinceLastPolling = 0;
    private EventMessageListener eventMessageListener;
    private int currentRecalculatingCycle;
    private int firstPeriodPulse;
    private int lastPeriodPulse;

    private void Start()
    {
        eventMessageListener = GetComponent<EventMessageListener>();
        currentRecalculatingCycle = 0;
        firstPeriodPulse = 0;
        eventMessageListener.MessageArrived += GetMessageFromSerial;
        eventMessageListener.ConnectionChanged += SetConnectionWithSerial;
    }

    private void FixedUpdate()
    {
        timeSinceLastPolling += Time.deltaTime;
        if (timeSinceLastPolling > _pollingRateSeconds)
        {
            if (_usePlaceholder)
            {
                GetBiofeedbackFromPlaceholder();
            }
            else
            {
                SendMessageToSerialController();
            }

            timeSinceLastPolling = 0;
        }
    }

    private void OnDestroy()
    {
        eventMessageListener.MessageArrived -= GetMessageFromSerial;
        eventMessageListener.ConnectionChanged -= SetConnectionWithSerial;
    }

    private void SetConnectionWithSerial(bool isConnected)
    {
        connected = isConnected;

        if (connected)
        {
            DebugLog("Connection established");
            SendMessageToSerialController();
        }
        else
        {
            DebugLog("Connection attempt failed or disconnection detected");
        }
    }

    private void GetMessageFromSerial(string msg)
    {
        string messageFromBiofeedback = msg;
        DebugLog("Serial controller returned message: " + messageFromBiofeedback);

        int pulseNumber = GetPulseFromMessage(messageFromBiofeedback);
        CalculateAcceleration(pulseNumber);
    }

    private void GetBiofeedbackFromPlaceholder()
    {
        string pulseMessage = PULSE_PREFIX + _placeholderPulse;

        int pulseNumber = GetPulseFromMessage(pulseMessage);
        CreatePlaceholderAcceleration(_placeholderAcceleration);
    }


    private void SendMessageToSerialController()
    {
        if (!connected)
        {
            PulseReceived?.Invoke(PULSE_NOT_RECEIVED);
            DebugErr($"Failed to retrieve data from the device. The device is not responding. The heart rate value is set to {PULSE_NOT_RECEIVED.ToString()}");
        }
        _serialController.SendSerialMessage(PULSE_REQUEST_MESSAGE);
        DebugLog("Send message to serial controller: " + PULSE_REQUEST_MESSAGE);
    }

    private int GetPulseFromMessage(string messageFromBiofeedback)
    {
        if (messageFromBiofeedback != null && messageFromBiofeedback.Contains(PULSE_PREFIX))
        {
            string pulseNumberAsString = messageFromBiofeedback.Replace(PULSE_PREFIX, "");
            int receivedPulseNumber = int.Parse(pulseNumberAsString);
            PulseReceived?.Invoke(receivedPulseNumber);
            return receivedPulseNumber;
        }

        return 0;
    }

    private void CalculateAcceleration(int pulse)
    {
        // TODO Уточнить формулу получения ускорения пульса
        float acceleration = 0.0f;
        currentRecalculatingCycle++;
        if (currentRecalculatingCycle >= _recalculatingCyclePeriod)
        {
            currentRecalculatingCycle = 0;
            int pulseRange = pulse - firstPeriodPulse;
            acceleration = pulseRange / (_pollingRateSeconds * _recalculatingCyclePeriod);
            DebugLog($"Acceleration was recalculated: {acceleration} = {pulseRange.ToString()}/({_pollingRateSeconds.ToString()}*{_recalculatingCyclePeriod.ToString()})");

            AccelerationCalculated?.Invoke(acceleration);
            firstPeriodPulse = pulse;
        }
    }

    private void CreatePlaceholderAcceleration(float acceleration)
    {
        currentRecalculatingCycle++;
        if (currentRecalculatingCycle >= _recalculatingCyclePeriod)
        {
            currentRecalculatingCycle = 0;
            AccelerationCalculated?.Invoke(acceleration);
        }
    }

    private void DebugLog(string message)
    {
        if (_debug)
        {
            Debug.Log($"[{name}]: " + message);
        }
    }
    
    private void DebugErr(string message)
    {
        if (_debug)
        {
            Debug.LogError($"[{name}]: " + message);
        }
    }
}
\end{minted}
\subsubsection*{AbstractProjectile.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>
/// Abstract class of an object moving from the spawn point to the point of its destruction.
/// The projectile performs an action implemented in the implementation
/// when it comes in contact with <see cref="PlayerBodypart"/>
/// </para>
/// </summary>
[RequireComponent(typeof(Rigidbody))]
public abstract class AbstractProjectile : MonoBehaviour
{
    /// <summary>
    /// <para><see cref="LevelManager"/> reference</para>
    /// </summary>
    protected LevelManager levelManager;

    private Transform destroyPoint;
    private float movementSpeed = 6f;
    private ProjectileSpawner projectileSpawner;
    private bool isBrickMove;

    protected virtual void Start()
    {
        isBrickMove = true;
    }

    protected virtual void FixedUpdate()
    {
        if (isBrickMove)
        {
            Move();
        }

        CheckDestination();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.TryGetComponent(out PlayerBodypart player) && isBrickMove)
        {
            isBrickMove = false;
            PerformAction();
        }
    }

    private void OnDestroy()
    {
        projectileSpawner.RemoveProjectileFromSpawnedList(this);
    }

    private void Move()
    {
        transform.position = Vector3.MoveTowards(transform.position, destroyPoint.position, movementSpeed);
    }

    private void CheckDestination()
    {
        if (transform.position == destroyPoint.position)
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// <para>Set level manager reference</para>
    /// </summary>
    /// <param name="levelManager">The level manager reference</param>
    public void SetLevelManager(LevelManager levelManager)
    {
        this.levelManager = levelManager;
    }

    /// <summary>
    /// <para>Set projectile spawner</para>
    /// </summary>
    /// <param name="projectileSpawner">The projectile spawner</param>
    public void SetSpawner(ProjectileSpawner projectileSpawner)
    {
        this.projectileSpawner = projectileSpawner;
    }

    /// <summary>
    /// <para>Set projectile movement speed</para>
    /// </summary>
    /// <param name="movementSpeed">The projectile movement speed</param>
    public void SetMovementSpeed(float movementSpeed)
    {
        this.movementSpeed = movementSpeed;
    }

    /// <summary>
    /// <para>Set point of projectile destruction</para>
    /// </summary>
    /// <param name="destroyPoint">Phe point of projectile destruction</param>
    public void SetDestroyPoint(Transform destroyPoint)
    {
        this.destroyPoint = destroyPoint;
    }

    /// <summary>
    /// <para>The action that will be performed when a projectile comes into contact with <see cref="PlayerBodypart"/></para>
    /// </summary>
    protected abstract void PerformAction();
}
\end{minted}
\subsubsection*{NegativeBrick.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>
/// A <see cref="AbstractProjectile">projectile</see> that looks like a brick.
/// If it comes in contact with player, it will take away part of his health points.
/// </para>
/// </summary>
public class NegativeBrick : AbstractProjectile
{
    [Tooltip("The amount of health that will be taken away from the player when the projectile comes into contact with the projectile")]
    [Range(0, 100)]
    [SerializeField] private int _hpDrain = 1;
    [Header("Blast settings")]
    [SerializeField] private float _crashForce = 6f;
    [SerializeField] private float _crashRadius = 6f;
    [SerializeField] private float _destructionTimeSec = 2.5f;

    /// <summary>
    /// <inheritdoc cref="AbstractProjectile.PerformAction"/>
    /// </summary>
    protected override void PerformAction()
    {
        levelManager?.DrainHealthPoint(_hpDrain);
        Crash(_crashForce, _crashRadius);
    }

    private void Crash(float force, float radius)
    {
        if (TryGetComponent(out Rigidbody rigidbody))
        {
            // Вернуть объекту возможность физического взаимодействия
            rigidbody.isKinematic = false;
            rigidbody.useGravity = true;
            // Растолкать объект в разные стороны
            rigidbody.AddExplosionForce(force,
                transform.position + new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f),
                    Random.Range(-1f, 1f)), radius);
        }
        Destroy(gameObject,_destructionTimeSec);
    }
}
\end{minted}
\subsubsection*{PositiveBrick.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using DG.Tweening;
using UnityEngine;

/// <summary>
/// <para>
/// A <see cref="AbstractProjectile">projectile</see> that looks like a brick.
/// If it comes in contact with player, it will increase the player's score
/// </para>
/// </summary>
[RequireComponent(typeof(MeshRenderer))]
public class PositiveBrick : AbstractProjectile
{
    [Tooltip("The number of points a player will get")] [Range(1, 100)] 
    [SerializeField] private int _scorePoints;

    [Header("Vanish settings")] 
    [SerializeField] private float _transformMultiplier;
    [SerializeField] private float _vanishSpeed;

    private bool isVanishing;

    /// <summary>
    /// <inheritdoc cref="AbstractProjectile.PerformAction"/>
    /// </summary>
    protected override void PerformAction()
    {
        levelManager.AddScore(_scorePoints);
        Vanishing();
    }

    private void Vanishing()
    {
        transform.DOScale(transform.localScale * _transformMultiplier, _vanishSpeed);

        if (TryGetComponent(out MeshRenderer meshRenderer))
        {
            meshRenderer.material.DOFade(0f, _vanishSpeed).OnComplete(() => Destroy(gameObject));
        }
    }
}
\end{minted}
\subsubsection*{ProjectileSpawner.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using Random = UnityEngine.Random;

/// <summary>
/// <para>Specific spavn speed settings for a particular game speed state</para>
/// </summary>
[Serializable]
struct SpawnerSpeed
{
    public Speed ForSpeed;
    public float MovementSpeed;
    [Range(1, 300)] 
    public float SpawnSpeed;
}

/// <summary>
/// <para>Spawned projectile info</para>
/// </summary>
[Serializable]
struct SpawnedProjectile
{
    public AbstractProjectile SpawnedObject;
    [Range(0, 100)] 
    public int SpawnChance;
    public ObjectMovement[] MovementPoints;
}

/// <summary>
/// <para>The component that performs projectile spawning</para>
/// It is a <see cref="AbstractSpeedChangingComponent"/>
/// </summary>
public class ProjectileSpawner : AbstractSpeedChangingComponent
{
    private const float SPEED_DIVIDER = 70;

    [SerializeField] private LevelManager _levelManager;
    [SerializeField] private SpawnedProjectile[] _projectiles;

    [SerializeField] private List<SpawnerSpeed> _speedSettings;

    private SpawnerSpeed currentSpeed;
    private bool isSpawnerActive = false;
    private float timeAfterSpawn;
    private List<AbstractProjectile> spawnedProjectiles;

    private void Awake()
    {
        spawnedProjectiles = new List<AbstractProjectile>();
        ValidateSS();
    }

    private void Start()
    {
        if (_speedSettings.Count == 0)
        {
            Debug.LogError($"[{name}]: Speed Settings List is empty.");
        }
        else
        {
            currentSpeed = _speedSettings[0];
        }

        _levelManager.GameStarted += StartSpawn;
        _levelManager.GameEnded += StopSpawnAndDestroyAllObjects;
        timeAfterSpawn = 200;
    }

    private void Update()
    {
        if (isSpawnerActive)
        {
            PreformSpawn();
        }
    }

    private void OnDestroy()
    {
        _levelManager.GameStarted -= StartSpawn;
        _levelManager.GameEnded -= StopSpawnAndDestroyAllObjects;
    }

    /// <summary>
    /// <para>Remove the specified projectile from the list of tracked projectiles</para>
    /// </summary>
    /// <param name="abstractProjectile">Removed projectile</param>
    public void RemoveProjectileFromSpawnedList(AbstractProjectile abstractProjectile)
    {
        spawnedProjectiles.Remove(abstractProjectile);
    }

    private void ValidateSS()
    {
        _speedSettings.Sort((ss1, ss2) => ss1.ForSpeed - ss2.ForSpeed);
        RemoveDuplicatesFromSS();
    }

    private void RemoveDuplicatesFromSS()
    {
        for (int i = _speedSettings.Count - 1; i > 0; i--)
        {
            if (_speedSettings[i].ForSpeed == _speedSettings[i - 1].ForSpeed)
            {
                _speedSettings.Remove(_speedSettings[i]);
            }
        }
    }

    private void StartSpawn()
    {
        isSpawnerActive = true;
    }

    private void StopSpawnAndDestroyAllObjects()
    {
        isSpawnerActive = false;
        for (int i = spawnedProjectiles.Count - 1; i >= 0; i--)
        {
            Destroy(spawnedProjectiles[i].gameObject);
        }
    }

    private void EndSpawn()
    {
        isSpawnerActive = false;
        _levelManager.EndGame();
    }

    private void PreformSpawn()
    {
        timeAfterSpawn += Time.deltaTime;
        if (timeAfterSpawn >= (100 / currentSpeed.SpawnSpeed))
        {
            SpawnRandomBrick();
            timeAfterSpawn = 0;
        }
    }

    private void SpawnRandomBrick()
    {
        int totalNumbers = 0;

        foreach (SpawnedProjectile brick in _projectiles)
        {
            totalNumbers += brick.SpawnChance;
        }

        int winner = Random.Range(1, totalNumbers);
        foreach (SpawnedProjectile brick in _projectiles)
        {
            totalNumbers -= brick.SpawnChance;
            if (winner >= totalNumbers)
            {
                SpawnBrick(brick);
                break;
            }
        }
    }

    private void SpawnBrick(SpawnedProjectile projectile)
    {
        ObjectMovement brickMovement = projectile.MovementPoints[Random.Range(0, projectile.MovementPoints.Length)];
        Transform spawnPoint = brickMovement.GetStartPoint();
        Transform destroyPoint = brickMovement.GetEndPoint();
        AbstractProjectile spawnProjectile =
            Instantiate(projectile.SpawnedObject, spawnPoint.position, brickMovement.transform.rotation);
        spawnProjectile.SetMovementSpeed(currentSpeed.MovementSpeed / SPEED_DIVIDER);
        spawnProjectile.SetDestroyPoint(destroyPoint);
        spawnProjectile.SetLevelManager(_levelManager);
        spawnProjectile.SetSpawner(this);
        spawnedProjectiles.Add(spawnProjectile);
    }

    /// <summary>
    /// <inheritdoc cref="AbstractSpeedChangingComponent.ChangeSpeed"/>
    /// </summary>
    /// <param name="speed"><inheritdoc cref="AbstractSpeedChangingComponent.ChangeSpeed"/></param>
    public override void ChangeSpeed(Speed speed)
    {
        if (speed == Speed.STOP)
        {
            EndSpawn();
            return;
        }

        if (_speedSettings.Count == 0)
        {
            Debug.LogError($"[{name}]: Speed Settings List is empty.");
            return;
        }

        foreach (SpawnerSpeed spawnerSpeed in _speedSettings)
        {
            if (spawnerSpeed.ForSpeed == speed)
            {
                currentSpeed = spawnerSpeed;
                return;
            }
        }

        LogNoSpeedSettingsFor(speed);
    }
}
\end{minted}
\subsubsection*{AbstractBiofeedbackManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Enumeration of heart rate states returned by biofeedback</para>
/// </summary>
[Serializable]
public enum PulseCondition
{
    SLOW,
    NORMAL,
    FAST,
    CRITICAL
}

/// <summary>
/// <para>Structure correlating the numerical value of the biofeedback indicator, heart rate state and color of the debug bar</para>
/// </summary>
[Serializable]
public struct PulseRateCondition
{
    [Tooltip("If pulse rate lower then selected, then set selected condition")]
    public float Rate;

    public PulseCondition Condition;
    public Color UIBarColor;
}

/// <summary>
/// <para> Abstract biofeedback manager class.</para>
/// It provides his subclass PulseConditionChange action that they must call to interact with game managers.
/// It also provides a list of <see cref="PulseRateCondition"/> and debug bar as script parameters.
/// And it provides <see cref="PulseReceiver"/> component and <see cref="PulseCondition"/> variable for biofeedback interaction.
/// </summary>
[RequireComponent(typeof(PulseReceiver))]
public abstract class AbstractBiofeedbackManager : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when <see cref="PulseCondition"/> change</para>
    /// </summary>
    public abstract event UnityAction<PulseCondition> PulseConditionChange;

    /// <summary>
    /// <para>List of <see cref="PulseRateCondition"/> used to determine heart rate status</para>
    /// </summary>
    [SerializeField] protected List<PulseRateCondition> _pulseRateConditions;

    /// <summary>
    /// <para><see cref="UINumberParameterBar"/> used to display the current parameter value on UI in debug mode</para>
    /// </summary>
    [SerializeField] protected UINumberParameterBar _debugUiBar;

    [SerializeField] private bool _showDebugUiBar;

    [Header("[Optional]")] 
    [SerializeField] private string _uiBarParameterName;

    /// <summary>
    /// <para><see cref="PulseReceiver"/> component</para>
    /// </summary>
    protected PulseReceiver pulseReceiver;

    /// <summary>
    /// <para>Current <see cref="PulseCondition"/> state</para>
    /// </summary>
    protected PulseCondition pulseCondition = PulseCondition.NORMAL;

    protected virtual void Start()
    {
        pulseReceiver = GetComponent<PulseReceiver>();
        ValidateConditionsList();
        if (_uiBarParameterName.Length > 0)
        {
            _debugUiBar?.SetParameterName("Pulse");
        }
    }

    private void Update()
    {
        _debugUiBar?.SetVisible(_showDebugUiBar);
    }

    private void ValidateConditionsList()
    {
        if (_pulseRateConditions.Count == 0)
        {
            Debug.LogError($"[{name}]: Conditions List is empty.");
            return;
        }

        _pulseRateConditions.Sort((prc1, prc2) => (int)(prc1.Rate * 100 - prc2.Rate * 100));
        RemoveDuplicateFromPACList();
    }

    private void RemoveDuplicateFromPACList()
    {
        for (int i = _pulseRateConditions.Count - 1; i >= 1; i--)
        {
            if (_pulseRateConditions[i].Rate == _pulseRateConditions[i - 1].Rate)
            {
                _pulseRateConditions.Remove(_pulseRateConditions[i]);
            }
        }
    }

    /// <summary>
    /// <para>Getter for current pulse condition</para>
    /// </summary>
    /// <returns>Current pulse condition</returns>
    public PulseCondition GetCurrentPulseCondition()
    {
        return pulseCondition;
    }
}
\end{minted}
\subsubsection*{AbstractSpeedChangingComponent.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

/// <summary>
/// <para>Enumeration of game speed states</para>
/// </summary>
[Serializable]
public enum Speed
{
    STOP,
    SLOW,
    NORMAL,
    FAST
}

/// <summary>
/// <para>Abstract class of component that changes its behavior depending on current game speed</para>
/// </summary>
public abstract class AbstractSpeedChangingComponent : MonoBehaviour
{
    /// <summary>
    /// <para>Change the behavior of this component according to selected <see cref="Speed"/></para>
    /// </summary>
    /// <param name="speed">the selected <see cref="Speed"/></param>
    public abstract void ChangeSpeed(Speed speed);

    protected void LogNoSpeedSettingsFor(Speed speed)
    {
        Debug.LogError($"[{name}]: No speed settings are specified for speed {Enum.GetName(typeof(Speed), speed)}.");
    }
}
\end{minted}
\subsubsection*{LevelManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Level manager script that controls events occurring in the level scene</para>
/// </summary>
public class LevelManager : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when the game starts</para>
    /// </summary>
    public event UnityAction GameStarted;

    /// <summary>
    /// <para>Action triggered when the game ends</para>
    /// </summary>
    public event UnityAction GameEnded;

    [SerializeField] private UIHPBar _hpBar;
    [SerializeField] private MultipleButtons _multipleButtons;
    [Range(1, 100)] 
    [SerializeField] private int _hpCount;
    [SerializeField] private UISmoothChangeNumberParameterBar _scoreBar;
    [SerializeField] private AbstractBiofeedbackManager _biofeedbackManager;
    [SerializeField] private AbstractSpeedChangingComponent[] _speedChangingComponents;
    [SerializeField] private bool _startGame;

    private void Start()
    {
        Cursor.visible = false;
        _hpBar.ResetHP();
        _scoreBar.SetParameterValue(0);
        _hpBar.OutOfHP += EndGame;
        _multipleButtons.ButtonsPressed += StartGame;
        if (_biofeedbackManager)
        {
            _biofeedbackManager.PulseConditionChange += ChangeGameSpeedAccordingToPulse;
        }
        else
        {
            Debug.LogError($"[{name}]: BiofeedbackManager не установлен");
        }
    }

    private void Update()
    {
        if (_startGame)
        {
            _startGame = false;
            StartGame();
        }
    }

    private void OnDestroy()
    {
        _hpBar.OutOfHP -= EndGame;
        _multipleButtons.ButtonsPressed -= StartGame;
        if (_biofeedbackManager)
        {
            _biofeedbackManager.PulseConditionChange -= ChangeGameSpeedAccordingToPulse;
        }
    }

    /// <summary>
    /// <para>Start game method</para>
    /// </summary>
    public void StartGame()
    {
        _multipleButtons.Hide();
        if (_biofeedbackManager?.GetCurrentPulseCondition() == PulseCondition.CRITICAL)
        {
            Debug.Log("Критическое состояние пульса. Запрет на старт игры");
            _multipleButtons.Show();
            return;
        }

        Debug.Log("Игра началась");
        _hpBar.SetHPCount(_hpCount);
        _scoreBar.SetParameterValue(0);
        GameStarted?.Invoke();
    }

    /// <summary>
    /// <para>End game method</para>
    /// </summary>
    public void EndGame()
    {
        Debug.Log("Игра окончена");
        GameEnded?.Invoke();
        _multipleButtons.Show();
    }

    /// <summary>
    /// <para>Method that takes away selected count of health points from player</para>
    /// </summary>
    /// <param name="count">Taken away health points count</param>
    public void DrainHealthPoint(int count)
    {
        _hpBar.AddHPToCurrent(-count);
    }

    /// <summary>
    /// <para>Method that increases a player's score by selected number of points</para>
    /// </summary>
    /// <param name="count">Points count added to the player's score</param>
    public void AddScore(int count)
    {
        _scoreBar.AddValue(count);
    }

    /// <summary>
    /// <para>Method that give selected count of health points to player</para>
    /// </summary>
    /// <param name="count">Given health points count</param>
    public void AddHealthPoint(int count)
    {
        _hpBar.AddHPToCurrent(count);
    }

    /// <summary>
    /// <para>Method that changes game speed according to <see cref="PulseCondition"/></para>
    /// </summary>
    /// <param name="pulseCondition"><see cref="PulseCondition"/> depending on which the game speed will be changed</param>
    public void ChangeGameSpeedAccordingToPulse(PulseCondition pulseCondition)
    {
        switch (pulseCondition)
        {
            case PulseCondition.CRITICAL:
                ChangeGameSpeed(Speed.STOP);
                break;
            case PulseCondition.SLOW:
                ChangeGameSpeed(Speed.FAST);
                break;
            case PulseCondition.NORMAL:
                ChangeGameSpeed(Speed.NORMAL);
                break;
            case PulseCondition.FAST:
                ChangeGameSpeed(Speed.SLOW);
                break;
        }
    }

    private void ChangeGameSpeed(Speed newSpeed)
    {
        foreach (AbstractSpeedChangingComponent speedChangingComponent in _speedChangingComponents)
        {
            speedChangingComponent.ChangeSpeed(newSpeed);
        }
    }
}
\end{minted}
\subsubsection*{PulseAccelerationManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Implementing a <see cref="AbstractBiofeedbackManager"/> through heart rate acceleration</para>
/// </summary>
public class PulseAccelerationManager : AbstractBiofeedbackManager
{
    /// <summary>
    /// <inheritdoc cref="AbstractBiofeedbackManager.PulseConditionChange"/>
    /// </summary>
    public override event UnityAction<PulseCondition> PulseConditionChange;
    
    private float acceleration = 80;

    protected override void Start()
    {
        base.Start();
        pulseReceiver.AccelerationCalculated += SetAcceleration;
    }

    private void OnDestroy()
    {
        pulseReceiver.AccelerationCalculated -= SetAcceleration;
    }

    private void SetAcceleration(float acceleration)
    {
        if (acceleration != this.acceleration)
        {
            this.acceleration = acceleration;
            RecalculateCondition();
            _debugUiBar?.SetParameterValue(this.acceleration);
        }
    }

    private void RecalculateCondition()
    {
        if (_pulseRateConditions.Count == 0)
        {
            Debug.LogError($"[{name}]: Pulse Rate Conditions List is empty.");
            return;
        }

        // TODO Определить как изменять состояние пульса в зависимости от ускарения
        for (int i = 0; i < _pulseRateConditions.Count; i++)
        {
            if (_pulseRateConditions[i].Condition == PulseCondition.NORMAL)
            {
                SetNewPulseConditionFromList(i);
                return;
            }
        }
    }

    private void SetNewPulseConditionFromList(int elementIndex)
    {
        PulseRateCondition selectedPulseAccelerationCondition = _pulseRateConditions[elementIndex];
        PulseCondition newCondition = selectedPulseAccelerationCondition.Condition;
        _debugUiBar?.SetColor(selectedPulseAccelerationCondition.UIBarColor);
        if (pulseCondition != newCondition)
        {
            pulseCondition = newCondition;
            PulseConditionChange?.Invoke(pulseCondition);
        }
    }
}
\end{minted}
\subsubsection*{PulseManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Implementing a <see cref="AbstractBiofeedbackManager"/> through heart rate</para>
/// </summary>
public class PulseManager : AbstractBiofeedbackManager
{
    /// <summary>
    /// <inheritdoc cref="AbstractBiofeedbackManager.PulseConditionChange"/>
    /// </summary>
    public override event UnityAction<PulseCondition> PulseConditionChange;
    
    private int pulse = 80;

    protected override void Start()
    {
        base.Start();
        pulseReceiver.PulseReceived += SetPulse;
    }


    private void OnDestroy()
    {
        pulseReceiver.PulseReceived -= SetPulse;
    }

    private void SetPulse(int newPulse)
    {
        if (newPulse != pulse)
        {
            pulse = newPulse;
            RecalculateCondition();
            _debugUiBar?.SetParameterValue(pulse);
        }
    }

    private void RecalculateCondition()
    {
        if (_pulseRateConditions.Count == 0)
        {
            Debug.LogError($"[{name}]: Pulse Rate Conditions List is empty.");
            return;
        }

        for (int i = 0; i < _pulseRateConditions.Count; i++)
        {
            PulseRateCondition currentPulseRateCondition = _pulseRateConditions[i];
            if (pulse < currentPulseRateCondition.Rate)
            {
                SetNewPulseConditionFromList(i);
                return;
            }
        }

        SetNewPulseConditionFromList(_pulseRateConditions.Count - 1);
    }

    private void SetNewPulseConditionFromList(int elementIndex)
    {
        PulseRateCondition selectedPulseRateCondition = _pulseRateConditions[elementIndex];
        PulseCondition newCondition = selectedPulseRateCondition.Condition;
        _debugUiBar?.SetColor(selectedPulseRateCondition.UIBarColor);
        if (pulseCondition != newCondition)
        {
            pulseCondition = newCondition;
            PulseConditionChange?.Invoke(pulseCondition);
        }
    }
}
\end{minted}
\subsubsection*{ObjectMovement.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>A component used to specify the trajectory of an object</para>
/// </summary>
[ExecuteAlways]
public class ObjectMovement : MonoBehaviour
{
    [SerializeField] private Transform _startPoint;
    [SerializeField] private Transform _endPoint;

    private void Start()
    {
        if (Application.IsPlaying(this))
        {
            DestroyChildren(_startPoint);
            DestroyChildren(_endPoint);
        }
    }

    private void DestroyChildren(Transform parent)
    {
        foreach (Transform child in parent)
        {
            Destroy(child.gameObject);
        }
    }

    private void Update()
    {
        if (_startPoint && _endPoint && !Application.isPlaying)
        {
            Color drawColor = _endPoint.localPosition.z - _startPoint.localPosition.z > 0 ? Color.blue : Color.red;
            _startPoint.localPosition = new Vector3(0, 0, 0);
            _endPoint.localPosition = new Vector3(0, 0, _endPoint.localPosition.z);
            Debug.DrawLine(_startPoint.position, _endPoint.position, drawColor);
        }
    }

    /// <summary>
    /// Get the starting point of the object movement
    /// </summary>
    /// <returns>The starting point of the object movement</returns>
    public Transform GetStartPoint()
    {
        return _startPoint;
    }

    /// <summary>
    /// Get the ending point of the object movement
    /// </summary>
    /// <returns>The ending point of the object movement</returns>
    public Transform GetEndPoint()
    {
        return _endPoint;
    }
}
\end{minted}
\subsubsection*{MultipleButtons.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Script that triggers a multiple <see cref="ObjectButton"/> press action</para>
/// </summary>
public class MultipleButtons : MonoBehaviour
{
    /// <summary>
    /// <para>Simultaneous <see cref="ObjectButton"/> press action</para>
    /// </summary>
    public event UnityAction ButtonsPressed;

    [SerializeField] private ObjectButton[] _objectButtons;

    private List<ObjectButton> activeStartButtons;
    private bool isButtonsHide = false;
    private float hideDuration = 1;

    private void Start()
    {
        activeStartButtons = new List<ObjectButton>();
        foreach (ObjectButton startButton in _objectButtons)
        {
            startButton.ButtonPressed += ActivateStartButton;
        }
    }

    private void OnDestroy()
    {
        foreach (ObjectButton startButton in _objectButtons)
        {
            startButton.ButtonPressed -= ActivateStartButton;
        }
    }

    private void ActivateStartButton(ObjectButton objectButton)
    {
        if (isButtonsHide || activeStartButtons.Contains(objectButton))
        {
            return;
        }

        activeStartButtons.Add(objectButton);
        objectButton.transform.DOScale(0.7f, 1);

        if (activeStartButtons.Count >= _objectButtons.Length)
        {
            ButtonsPressed?.Invoke();
        }
    }

    /// <summary>
    /// <para>Show buttons if they are hidden</para>
    /// </summary>
    public void Show()
    {
        if (isButtonsHide)
        {
            transform.DOMoveY(0, hideDuration);
            foreach (ObjectButton startButton in _objectButtons)
            {
                startButton.transform.DOScale(1f, 1);
            }

            isButtonsHide = false;
            activeStartButtons.Clear();
        }
    }

    /// <summary>
    /// <para>Hide buttons if they are not hide</para>
    /// </summary>
    public void Hide()
    {
        if (!isButtonsHide)
        {
            isButtonsHide = true;
            transform.DOMoveY(-3, hideDuration);
        }

        activeStartButtons.Clear();
    }
}
\end{minted}
\subsubsection*{ObjectButton.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Button object component. When a <see cref="PlayerBodypart"/> touches this object, the button press action will be triggered</para>
/// </summary>
[RequireComponent(typeof(Rigidbody), typeof(Collider))]
public class ObjectButton : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when a <see cref="PlayerBodypart"/> touches button object</para>
    /// </summary>
    public event UnityAction<ObjectButton> ButtonPressed;

    private void OnTriggerEnter(Collider other)
    {
        if (other.TryGetComponent(out PlayerBodypart player))
        {
            Debug.Log("PlayerBodypart ударил кнопку: " + name);
            ButtonPressed?.Invoke(this);
        }
    }
}
\end{minted}
\subsubsection*{ModifiedPuppetAvatar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Azure.Kinect.BodyTracking;
using UnityEngine;

[Serializable]
struct BoolVector
{
    public bool X;
    public bool Y;
    public bool Z;
}

[Serializable]
struct FloatVector
{
    public float X;
    public float Y;
    public float Z;
}

/// <summary>
/// <para>Modifications to the avatar position, compared to the tracked body</para>
/// </summary>
[Serializable]
struct PositionModification
{
    public BoolVector FreezePosition;
    public FloatVector PositionOffset;
    [Header("Debug")] public FloatVector PositionScale;
}

/// <summary>
/// <para>Script used to control an avatar using the Azure Kinect.</para>
/// <para>This script requires the main camera in the scene. But it must not be a child object of the object using this script</para>
/// </summary>
public class ModifiedPuppetAvatar : MonoBehaviour
{
    [Tooltip("TrackerHandler TrackerHandler located in the Kinect4AzureTrackerAllInOne prefab")] 
    [SerializeField] private TrackerHandler _kinectDevice;

    [Tooltip("pointBody object which is a child of Kinect4AzureTrackerAllInOne prefab")] 
    [SerializeField] private Transform _rootPosition;

    [Tooltip("The root transform object of the avatar armature")] 
    [SerializeField] private Transform _characterRootTransform;

    [SerializeField] private PositionModification _positionModification;

    private Dictionary<JointId, Quaternion> absoluteOffsetMap;
    private Animator puppetAnimator;
    private Quaternion modelRotation;
    private new GameObject camera;

    private static HumanBodyBones MapKinectJoint(JointId joint)
    {
        // https://docs.microsoft.com/en-us/azure/Kinect-dk/body-joints
        switch (joint)
        {
            case JointId.Pelvis: return HumanBodyBones.Hips;
            case JointId.SpineNavel: return HumanBodyBones.Spine;
            case JointId.SpineChest: return HumanBodyBones.Chest;
            case JointId.Neck: return HumanBodyBones.Neck;
            case JointId.Head: return HumanBodyBones.Head;
            case JointId.HipLeft: return HumanBodyBones.LeftUpperLeg;
            case JointId.KneeLeft: return HumanBodyBones.LeftLowerLeg;
            case JointId.AnkleLeft: return HumanBodyBones.LeftFoot;
            case JointId.FootLeft: return HumanBodyBones.LeftToes;
            case JointId.HipRight: return HumanBodyBones.RightUpperLeg;
            case JointId.KneeRight: return HumanBodyBones.RightLowerLeg;
            case JointId.AnkleRight: return HumanBodyBones.RightFoot;
            case JointId.FootRight: return HumanBodyBones.RightToes;
            case JointId.ClavicleLeft: return HumanBodyBones.LeftShoulder;
            case JointId.ShoulderLeft: return HumanBodyBones.LeftUpperArm;
            case JointId.ElbowLeft: return HumanBodyBones.LeftLowerArm;
            case JointId.WristLeft: return HumanBodyBones.LeftHand;
            case JointId.ClavicleRight: return HumanBodyBones.RightShoulder;
            case JointId.ShoulderRight: return HumanBodyBones.RightUpperArm;
            case JointId.ElbowRight: return HumanBodyBones.RightLowerArm;
            case JointId.WristRight: return HumanBodyBones.RightHand;
            default: return HumanBodyBones.LastBone;
        }
    }

    private void Start()
    {
        modelRotation = transform.rotation;
        camera = GetMainCamera();

        puppetAnimator = GetComponent<Animator>();
        Transform _rootJointTransform = _characterRootTransform;

        absoluteOffsetMap = new Dictionary<JointId, Quaternion>();
        for (int i = 0; i < (int)JointId.Count; i++)
        {
            HumanBodyBones hbb = MapKinectJoint((JointId)i);
            if (hbb != HumanBodyBones.LastBone)
            {
                Transform transform = puppetAnimator.GetBoneTransform(hbb);
                Quaternion absOffset = GetSkeletonBone(puppetAnimator, transform.name).rotation;
                // find the absolute offset for the tpose
                while (!ReferenceEquals(transform, _rootJointTransform))
                {
                    transform = transform.parent;
                    absOffset = GetSkeletonBone(puppetAnimator, transform.name).rotation * absOffset;
                }

                absoluteOffsetMap[(JointId)i] = absOffset;
            }
        }
    }

    private GameObject GetMainCamera()
    {
        GameObject foundMainCamera = GameObject.FindGameObjectWithTag("MainCamera");

        Camera[] childCameras = GetComponentsInChildren<Camera>(true);
        foreach (Camera childCamera in childCameras)
        {
            if (childCamera.gameObject == foundMainCamera)
            {
                return null;
            }
        }

        return foundMainCamera;
    }

    private static SkeletonBone GetSkeletonBone(Animator animator, string boneName)
    {
        int count = 0;
        StringBuilder cloneName = new StringBuilder(boneName);
        cloneName.Append("(Clone)");
        foreach (SkeletonBone sb in animator.avatar.humanDescription.skeleton)
        {
            if (sb.name == boneName || sb.name == cloneName.ToString())
            {
                return animator.avatar.humanDescription.skeleton[count];
            }

            count++;
        }

        return new SkeletonBone();
    }

    // Update is called once per frame
    private void LateUpdate()
    {
        for (int j = 0; j < (int)JointId.Count; j++)
        {
            if (MapKinectJoint((JointId)j) != HumanBodyBones.LastBone && absoluteOffsetMap.ContainsKey((JointId)j))
            {
                // get the absolute offset
                Transform finalJoint = puppetAnimator.GetBoneTransform(MapKinectJoint((JointId)j));
                finalJoint.rotation = GetRotationFromDevice(j);
                if (j == 0)
                {
                    finalJoint.position = GetPositionFromDevice(j);
                }
            }
        }

        RotateFullObject();
    }

    private Quaternion GetRotationFromDevice(int j)
    {
        Quaternion absOffset = absoluteOffsetMap[(JointId)j];

        return absOffset * Quaternion.Inverse(absOffset) *
               _kinectDevice.absoluteJointRotations[j] * absOffset;
    }

    private Vector3 GetPositionFromDevice(int j)
    {
        Vector3 positionOffset = _kinectDevice.absoluteJointPosition[j];
        positionOffset = ApplyConstraints(positionOffset);
        positionOffset = ApplyOffsets(positionOffset);
        positionOffset = AddOffsetToRootPosition(positionOffset);
        positionOffset = ApplyScaleToPosition(positionOffset);

        return _characterRootTransform.position + positionOffset;
    }

    private Vector3 ApplyConstraints(Vector3 position)
    {
        return new Vector3(
            _positionModification.FreezePosition.X ? 0 : position.x,
            _positionModification.FreezePosition.Y ? 0 : position.y,
            _positionModification.FreezePosition.Z ? 0 : position.z);
    }

    private Vector3 ApplyOffsets(Vector3 position)
    {
        return new Vector3(
            position.x + _positionModification.PositionOffset.X,
            position.y + _positionModification.PositionOffset.Y,
            position.z + _positionModification.PositionOffset.Z);
    }

    private Vector3 AddOffsetToRootPosition(Vector3 positionOffset)
    {
        Vector3 rootLocalPosition = _rootPosition.localPosition;
        return new Vector3(
            rootLocalPosition.x + positionOffset.x,
            rootLocalPosition.y + positionOffset.y,
            rootLocalPosition.z + positionOffset.z);
    }

    private Vector3 ApplyScaleToPosition(Vector3 position)
    {
        return new Vector3(
            position.x * _positionModification.PositionScale.X,
            position.y * _positionModification.PositionScale.Y,
            position.z * _positionModification.PositionScale.Z);
    }

    private void RotateFullObject()
    {
        if (camera)
        {
            transform.rotation *= modelRotation;
            transform.rotation *= camera.transform.rotation;
        }
    }
}
\end{minted}
\subsubsection*{PuppetAvatarDeviceConfiguration.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using UnityEngine;

[RequireComponent(typeof(TrackerHandler))]
public class PuppetAvatarDeviceConfiguration : MonoBehaviour
{
    public BackgroundData m_lastFrameData = new BackgroundData();

    // Handler for SkeletalTracking thread.
    private TrackerHandler trackerHandler;
    private SkeletalTrackingProvider m_skeletalTrackingProvider;


    void Start()
    {
        //tracker ids needed for when there are two trackers
        const int TRACKER_ID = 0;
        m_skeletalTrackingProvider = new SkeletalTrackingProvider(TRACKER_ID);
        trackerHandler = GetComponent<TrackerHandler>();
    }

    void Update()
    {
        if (m_skeletalTrackingProvider.IsRunning)
        {
            if (m_skeletalTrackingProvider.GetCurrentFrameData(ref m_lastFrameData))
            {
                if (m_lastFrameData.NumOfBodies != 0)
                {
                    trackerHandler.updateTracker(m_lastFrameData);
                }
            }
        }
    }

    void OnApplicationQuit()
    {
        if (m_skeletalTrackingProvider != null)
        {
            m_skeletalTrackingProvider.Dispose();
        }
    }
}
\end{minted}
\subsubsection*{SkeletalTrackingProvider.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading;
using Microsoft.Azure.Kinect.BodyTracking;
using Microsoft.Azure.Kinect.Sensor;
using UnityEngine;
using UnityEngine.Events;

public class SkeletalTrackingProvider : BackgroundDataProvider
{
    
    private bool readFirstFrame = false;
    private TimeSpan initialTimestamp;
    private Configs configs { get; set; } = new Configs();

    public SkeletalTrackingProvider(int id) : base(id)
    {
        Debug.Log("in the skeleton provider constructor");
    }

    BinaryFormatter binaryFormatter { get; set; } = new BinaryFormatter();

    public Stream RawDataLoggingFile = null;

    protected override void RunBackgroundThreadAsync(int id, CancellationToken token)
    {
        try
        {
            Debug.Log("Starting body tracker background thread.");

            // Buffer allocations.
            BackgroundData currentFrameData = new BackgroundData();
            // Open device.
            using (Device device = Device.Open(id))
            {
                device.StartCameras(new DeviceConfiguration()
                {
                    CameraFPS = FPS.FPS30,
                    ColorResolution = ColorResolution.Off,
                    DepthMode = DepthMode.NFOV_Unbinned,
                    WiredSyncMode = WiredSyncMode.Standalone,
                });

                Debug.Log("Open K4A device successful. id " + id + "sn:" + device.SerialNum);

                var deviceCalibration = device.GetCalibration();

                using (Tracker tracker = Tracker.Create(deviceCalibration, new TrackerConfiguration() { ProcessingMode = TrackerProcessingMode.Gpu, SensorOrientation = SensorOrientation.Default }))
                {
                    Debug.Log("Body tracker created.");
                    while (!token.IsCancellationRequested)
                    {
                        using (Capture sensorCapture = device.GetCapture())
                        {
                            // Queue latest frame from the sensor.
                            tracker.EnqueueCapture(sensorCapture);
                        }

                        // Try getting latest tracker frame.
                        using (Frame frame = tracker.PopResult(TimeSpan.Zero, throwOnTimeout: false))
                        {
                            if (frame == null)
                            {
                                Debug.Log("Pop result from tracker timeout!");
                            }
                            else
                            {
                                IsRunning = true;
                                // Get number of bodies in the current frame.
                                currentFrameData.NumOfBodies = frame.NumberOfBodies;

                                // Copy bodies.
                                for (uint i = 0; i < currentFrameData.NumOfBodies; i++)
                                {
                                    currentFrameData.Bodies[i].CopyFromBodyTrackingSdk(frame.GetBody(i), deviceCalibration);
                                }

                                // Store depth image.
                                Capture bodyFrameCapture = frame.Capture;
                                Image depthImage = bodyFrameCapture.Depth;
                                if (!readFirstFrame)
                                {
                                    readFirstFrame = true;
                                    initialTimestamp = depthImage.DeviceTimestamp;
                                }
                                currentFrameData.TimestampInMs = (float)(depthImage.DeviceTimestamp - initialTimestamp).TotalMilliseconds;
                                currentFrameData.DepthImageWidth = depthImage.WidthPixels;
                                currentFrameData.DepthImageHeight = depthImage.HeightPixels;

                                // Read image data from the SDK.
                                var depthFrame = MemoryMarshal.Cast<byte, ushort>(depthImage.Memory.Span);

                                // Repack data and store image data.
                                int byteCounter = 0;
                                currentFrameData.DepthImageSize = currentFrameData.DepthImageWidth * currentFrameData.DepthImageHeight * 3;

                                for (int it = currentFrameData.DepthImageWidth * currentFrameData.DepthImageHeight - 1; it > 0; it--)
                                {
                                    byte b = (byte)(depthFrame[it] / (configs.SkeletalTracking.MaximumDisplayedDepthInMillimeters) * 255);
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                }

                                if (RawDataLoggingFile != null && RawDataLoggingFile.CanWrite)
                                {
                                    binaryFormatter.Serialize(RawDataLoggingFile, currentFrameData);
                                }

                                // Update data variable that is being read in the UI thread.
                                SetCurrentFrameData(ref currentFrameData);
                            }

                        }
                    }
                    Debug.Log("dispose of tracker now!!!!!");
                    tracker.Dispose();
                }
                device.Dispose();
            }
            if (RawDataLoggingFile != null)
            {
                RawDataLoggingFile.Close();
            }
        }
        catch (Exception e)
        {
            Debug.Log($"catching exception for background thread {e.Message}");
            token.ThrowIfCancellationRequested();
        }
    }
}
\end{minted}
\subsubsection*{TrackerHandler.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using System.Collections.Generic;
using UnityEngine;
using Microsoft.Azure.Kinect.BodyTracking;

public class TrackerHandler : MonoBehaviour
{
    public Dictionary<JointId, JointId> parentJointMap;
    Dictionary<JointId, Quaternion> basisJointMap;
    public Quaternion[] absoluteJointRotations = new Quaternion[(int)JointId.Count];
    public Vector3[] absoluteJointPosition = new Vector3[(int)JointId.Count];
    public bool drawSkeletons = true;
    Quaternion Y_180_FLIP = new Quaternion(0.0f, 1.0f, 0.0f, 0.0f);

    // Start is called before the first frame update
    void Awake()
    {
        parentJointMap = new Dictionary<JointId, JointId>();

        // pelvis has no parent so set to count
        parentJointMap[JointId.Pelvis] = JointId.Count;
        parentJointMap[JointId.SpineNavel] = JointId.Pelvis;
        parentJointMap[JointId.SpineChest] = JointId.SpineNavel;
        parentJointMap[JointId.Neck] = JointId.SpineChest;
        parentJointMap[JointId.ClavicleLeft] = JointId.SpineChest;
        parentJointMap[JointId.ShoulderLeft] = JointId.ClavicleLeft;
        parentJointMap[JointId.ElbowLeft] = JointId.ShoulderLeft;
        parentJointMap[JointId.WristLeft] = JointId.ElbowLeft;
        parentJointMap[JointId.HandLeft] = JointId.WristLeft;
        parentJointMap[JointId.HandTipLeft] = JointId.HandLeft;
        parentJointMap[JointId.ThumbLeft] = JointId.HandLeft;
        parentJointMap[JointId.ClavicleRight] = JointId.SpineChest;
        parentJointMap[JointId.ShoulderRight] = JointId.ClavicleRight;
        parentJointMap[JointId.ElbowRight] = JointId.ShoulderRight;
        parentJointMap[JointId.WristRight] = JointId.ElbowRight;
        parentJointMap[JointId.HandRight] = JointId.WristRight;
        parentJointMap[JointId.HandTipRight] = JointId.HandRight;
        parentJointMap[JointId.ThumbRight] = JointId.HandRight;
        parentJointMap[JointId.HipLeft] = JointId.SpineNavel;
        parentJointMap[JointId.KneeLeft] = JointId.HipLeft;
        parentJointMap[JointId.AnkleLeft] = JointId.KneeLeft;
        parentJointMap[JointId.FootLeft] = JointId.AnkleLeft;
        parentJointMap[JointId.HipRight] = JointId.SpineNavel;
        parentJointMap[JointId.KneeRight] = JointId.HipRight;
        parentJointMap[JointId.AnkleRight] = JointId.KneeRight;
        parentJointMap[JointId.FootRight] = JointId.AnkleRight;
        parentJointMap[JointId.Head] = JointId.Pelvis;
        parentJointMap[JointId.Nose] = JointId.Head;
        parentJointMap[JointId.EyeLeft] = JointId.Head;
        parentJointMap[JointId.EarLeft] = JointId.Head;
        parentJointMap[JointId.EyeRight] = JointId.Head;
        parentJointMap[JointId.EarRight] = JointId.Head;

        Vector3 zpositive = Vector3.forward;
        Vector3 xpositive = Vector3.right;
        Vector3 ypositive = Vector3.up;
        // spine and left hip are the same
        Quaternion leftHipBasis = Quaternion.LookRotation(xpositive, -zpositive);
        Quaternion spineHipBasis = Quaternion.LookRotation(xpositive, -zpositive);
        Quaternion rightHipBasis = Quaternion.LookRotation(xpositive, zpositive);
        // arms and thumbs share the same basis
        Quaternion leftArmBasis = Quaternion.LookRotation(ypositive, -zpositive);
        Quaternion rightArmBasis = Quaternion.LookRotation(-ypositive, zpositive);
        Quaternion leftHandBasis = Quaternion.LookRotation(-zpositive, -ypositive);
        Quaternion rightHandBasis = Quaternion.identity;
        Quaternion leftFootBasis = Quaternion.LookRotation(xpositive, ypositive);
        Quaternion rightFootBasis = Quaternion.LookRotation(xpositive, -ypositive);

        basisJointMap = new Dictionary<JointId, Quaternion>();

        // pelvis has no parent so set to count
        basisJointMap[JointId.Pelvis] = spineHipBasis;
        basisJointMap[JointId.SpineNavel] = spineHipBasis;
        basisJointMap[JointId.SpineChest] = spineHipBasis;
        basisJointMap[JointId.Neck] = spineHipBasis;
        basisJointMap[JointId.ClavicleLeft] = leftArmBasis;
        basisJointMap[JointId.ShoulderLeft] = leftArmBasis;
        basisJointMap[JointId.ElbowLeft] = leftArmBasis;
        basisJointMap[JointId.WristLeft] = leftHandBasis;
        basisJointMap[JointId.HandLeft] = leftHandBasis;
        basisJointMap[JointId.HandTipLeft] = leftHandBasis;
        basisJointMap[JointId.ThumbLeft] = leftArmBasis;
        basisJointMap[JointId.ClavicleRight] = rightArmBasis;
        basisJointMap[JointId.ShoulderRight] = rightArmBasis;
        basisJointMap[JointId.ElbowRight] = rightArmBasis;
        basisJointMap[JointId.WristRight] = rightHandBasis;
        basisJointMap[JointId.HandRight] = rightHandBasis;
        basisJointMap[JointId.HandTipRight] = rightHandBasis;
        basisJointMap[JointId.ThumbRight] = rightArmBasis;
        basisJointMap[JointId.HipLeft] = leftHipBasis;
        basisJointMap[JointId.KneeLeft] = leftHipBasis;
        basisJointMap[JointId.AnkleLeft] = leftHipBasis;
        basisJointMap[JointId.FootLeft] = leftFootBasis;
        basisJointMap[JointId.HipRight] = rightHipBasis;
        basisJointMap[JointId.KneeRight] = rightHipBasis;
        basisJointMap[JointId.AnkleRight] = rightHipBasis;
        basisJointMap[JointId.FootRight] = rightFootBasis;
        basisJointMap[JointId.Head] = spineHipBasis;
        basisJointMap[JointId.Nose] = spineHipBasis;
        basisJointMap[JointId.EyeLeft] = spineHipBasis;
        basisJointMap[JointId.EarLeft] = spineHipBasis;
        basisJointMap[JointId.EyeRight] = spineHipBasis;
        basisJointMap[JointId.EarRight] = spineHipBasis;
    }

    public void updateTracker(BackgroundData trackerFrameData)
    {
        //this is an array in case you want to get the n closest bodies
        int closestBody = findClosestTrackedBody(trackerFrameData);

        // render the closest body
        AvatarBody skeleton = trackerFrameData.Bodies[closestBody];
        renderSkeleton(skeleton, 0);
    }

    int findIndexFromId(BackgroundData frameData, int id)
    {
        int retIndex = -1;
        for (int i = 0; i < (int)frameData.NumOfBodies; i++)
        {
            if ((int)frameData.Bodies[i].Id == id)
            {
                retIndex = i;
                break;
            }
        }
        return retIndex;
    }

    private int findClosestTrackedBody(BackgroundData trackerFrameData)
    {
        int closestBody = -1;
        const float MAX_DISTANCE = 5000.0f;
        float minDistanceFromKinect = MAX_DISTANCE;
        for (int i = 0; i < (int)trackerFrameData.NumOfBodies; i++)
        {
            var pelvisPosition = trackerFrameData.Bodies[i].JointPositions3D[(int)JointId.Pelvis];
            Vector3 pelvisPos = new Vector3((float)pelvisPosition.X, (float)pelvisPosition.Y, (float)pelvisPosition.Z);
            if (pelvisPos.magnitude < minDistanceFromKinect)
            {
                closestBody = i;
                minDistanceFromKinect = pelvisPos.magnitude;
            }
        }
        return closestBody;
    }

    public void turnOnOffSkeletons()
    {
        drawSkeletons = !drawSkeletons;
        const int bodyRenderedNum = 0;
        for (int jointNum = 0; jointNum < (int)JointId.Count; jointNum++)
        {
            transform.GetChild(bodyRenderedNum).GetChild(jointNum).gameObject.GetComponent<MeshRenderer>().enabled = drawSkeletons;
            transform.GetChild(bodyRenderedNum).GetChild(jointNum).GetChild(0).GetComponent<MeshRenderer>().enabled = drawSkeletons;
        }
    }

    public void renderSkeleton(AvatarBody skeleton, int skeletonNumber)
    {
        for (int jointNum = 0; jointNum < (int)JointId.Count; jointNum++)
        {
            Vector3 jointPos = new Vector3(skeleton.JointPositions3D[jointNum].X, -skeleton.JointPositions3D[jointNum].Y, skeleton.JointPositions3D[jointNum].Z);
            absoluteJointPosition[jointNum] = jointPos;
            Vector3 offsetPosition = transform.rotation * jointPos;
            Vector3 positionInTrackerRootSpace = transform.position + offsetPosition;
            Quaternion jointRot = Y_180_FLIP * new Quaternion(skeleton.JointRotations[jointNum].X, skeleton.JointRotations[jointNum].Y,
                skeleton.JointRotations[jointNum].Z, skeleton.JointRotations[jointNum].W) * Quaternion.Inverse(basisJointMap[(JointId)jointNum]);
            absoluteJointRotations[jointNum] = jointRot;
            // these are absolute body space because each joint has the body root for a parent in the scene graph
            transform.GetChild(skeletonNumber).GetChild(jointNum).localPosition = jointPos;
            transform.GetChild(skeletonNumber).GetChild(jointNum).localRotation = jointRot;

            const int boneChildNum = 0;
            if (parentJointMap[(JointId)jointNum] != JointId.Head && parentJointMap[(JointId)jointNum] != JointId.Count)
            {
                Vector3 parentTrackerSpacePosition = new Vector3(skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].X,
                    -skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].Y, skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].Z);
                Vector3 boneDirectionTrackerSpace = jointPos - parentTrackerSpacePosition;
                Vector3 boneDirectionWorldSpace = transform.rotation * boneDirectionTrackerSpace;
                Vector3 boneDirectionLocalSpace = Quaternion.Inverse(transform.GetChild(skeletonNumber).GetChild(jointNum).rotation) * Vector3.Normalize(boneDirectionWorldSpace);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).localScale = new Vector3(1, 20.0f * 0.5f * boneDirectionWorldSpace.magnitude, 1);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).localRotation = Quaternion.FromToRotation(Vector3.up, boneDirectionLocalSpace);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).position = transform.GetChild(skeletonNumber).GetChild(jointNum).position - 0.5f * boneDirectionWorldSpace;
            }
            else
            {
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).gameObject.SetActive(false);
            }
        }
    }

    public Quaternion GetRelativeJointRotation(JointId jointId)
    {
        JointId parent = parentJointMap[jointId];
        Quaternion parentJointRotationBodySpace = Quaternion.identity;
        if (parent == JointId.Count)
        {
            parentJointRotationBodySpace = Y_180_FLIP;
        }
        else
        {
            parentJointRotationBodySpace = absoluteJointRotations[(int)parent];
        }
        Quaternion jointRotationBodySpace = absoluteJointRotations[(int)jointId];
        Quaternion relativeRotation =  Quaternion.Inverse(parentJointRotationBodySpace) * jointRotationBodySpace;

        return relativeRotation;
    }

}

\end{minted}
\subsubsection*{KeyboardObjectMovement.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Script used to move an object using the keyboard</para>
/// </summary>
public class KeyboardObjectMovement : MonoBehaviour
{
    [SerializeField] private Transform _movedObject;
    [SerializeField] private Transform _leftBorder;
    [SerializeField] private Transform _rightBorder;
    [SerializeField] private Transform _forwardBorder;
    [SerializeField] private Transform _backwardBorder;
    [SerializeField] private float _walkingSpeed = 6f;
    [SerializeField] private float _sitPosition = 0.9f;

    private Vector3 playerVelocity;
    private Vector3 maxPosition;
    private Vector3 minPosition;
    private float startYPosition;
    private float currentYPosition;

    private void Start()
    {
        gameObject.SetActive(_movedObject.gameObject.activeInHierarchy);
        SetXMaxMinPosition();
        SetZMaxMinPosition();
        startYPosition = gameObject.transform.localPosition.y;
        currentYPosition = startYPosition;
    }

    private void SetXMaxMinPosition()
    {
        if (!_leftBorder || !_rightBorder)
        {
            maxPosition.x = float.MaxValue;
            minPosition.x = float.MinValue;
        }
        else
        {
            maxPosition.x = Mathf.Max(_leftBorder.position.x, _rightBorder.position.x);
            minPosition.x = Mathf.Min(_leftBorder.position.x, _rightBorder.position.x);
        }
    }

    private void SetZMaxMinPosition()
    {
        if (!_forwardBorder || !_backwardBorder)
        {
            maxPosition.z = float.MaxValue;
            minPosition.z = float.MinValue;
        }
        else
        {
            maxPosition.z = Mathf.Max(_forwardBorder.position.z, _backwardBorder.position.z);
            minPosition.z = Mathf.Min(_forwardBorder.position.z, _backwardBorder.position.z);
        }
    }

    private void Update()
    {
        MoveLeftRight();
        MoveForwardBackward();
        Sit();
    }

    private void MoveLeftRight()
    {
        float horizontalMove = (-1.0f) * Input.GetAxis("Horizontal");
        float move = horizontalMove * _walkingSpeed * Time.deltaTime;
        Vector3 position = _movedObject.position;
        float newXPosition = Mathf.Clamp(position.x + move, minPosition.x, maxPosition.x);
        Vector3 newPosition = new Vector3(newXPosition, position.y, position.z);
        _movedObject.position = newPosition;
    }

    private void MoveForwardBackward()
    {
        float horizontalMove = (-1.0f) * Input.GetAxis("Vertical");
        float move = horizontalMove * _walkingSpeed * Time.deltaTime;
        Vector3 position = _movedObject.position;
        float newZPosition = Mathf.Clamp(position.z + move, minPosition.z, maxPosition.z);
        Vector3 newPosition = new Vector3(position.x, position.y, newZPosition);
        _movedObject.position = newPosition;
    }

    private void Sit()
    {
        if (Input.GetKey(KeyCode.LeftControl))
        {
            currentYPosition = startYPosition - _sitPosition;
        }
        else
        {
            currentYPosition = startYPosition;
        }

        Vector3 position = _movedObject.position;
        Vector3 newPosition = new Vector3(position.x, currentYPosition, position.z);
        _movedObject.position = newPosition;
    }
}
\end{minted}
\subsubsection*{PlayerBodypart.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Component used to define a player's body part</para>
/// </summary>
public class PlayerBodypart : MonoBehaviour
{ }

\end{minted}
\subsubsection*{UIHealthPoint.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// <para>Script for displaying one health point in UI</para>
/// </summary>
public class UIHealthPoint : MonoBehaviour
{
    [SerializeField] private Image _activeHeart;
    [SerializeField] private Image _notActiveHeart;
    [SerializeField] private bool _isActive;

    private void Start()
    {
        _activeHeart.gameObject.SetActive(_isActive);
        _notActiveHeart.gameObject.SetActive(!_isActive);
    }

    /// <summary>
    /// Set active state for health point
    /// </summary>
    /// <param name="isActive">Is health point active</param>
    public void SetActive(bool isActive)
    {
        _isActive = isActive;

        _activeHeart.gameObject.SetActive(_isActive);
        _notActiveHeart.gameObject.SetActive(!_isActive);
    }
}
\end{minted}
\subsubsection*{UIHPBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
using Quaternion = LightBuzz.Quaternion;

/// <summary>
/// <para>Script for displaying health bar in UI. Health bar consists of health points - UIHealthPoint</para>
/// <see cref="UIHealthPoint"/>
/// </summary>
public class UIHPBar : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when health points run out</para>
    /// </summary>
    public event UnityAction OutOfHP;

    [SerializeField] private int _hpCount;
    [SerializeField] private UIHealthPoint _uiHealthPointPrefab;
    [Range(0, 100)] [SerializeField] private float _prefabSpacing;
    private UIHealthPoint[] hpImagesArray;
    private int currentHP;
    private float hpImageWidth;
    private float hpImageHeight;

    private void Awake()
    {
        CreateNewBar();
    }

    /// <summary>
    /// <para>Set new health point count</para>
    /// </summary>
    /// <param name="count">New health point count</param>
    public void SetHPCount(int count)
    {
        if (_hpCount != count)
        {
            RemoveOldBar();
            _hpCount = count;
            CreateNewBar();
        }
        else
        {
            ResetHP();
        }
    }

    private void RemoveOldBar()
    {
        if (hpImagesArray != null)
        {
            for (int i = _hpCount - 1; i >= 0; i--)
            {
                Destroy(hpImagesArray[i].gameObject);
            }
        }
    }

    private void CreateNewBar()
    {
        hpImagesArray = new UIHealthPoint[_hpCount];
        currentHP = _hpCount;

        Transform prefabTransform = _uiHealthPointPrefab.transform;
        Rect imageRectTransform = ((RectTransform)prefabTransform).rect;
        hpImageWidth = imageRectTransform.width * prefabTransform.localScale.x;
        hpImageHeight = imageRectTransform.height * prefabTransform.localScale.y;
        for (int i = 0; i < _hpCount; i++)
        {
            var spawnedHeart = SpawnHeart(i);
            hpImagesArray[i] = spawnedHeart;
            spawnedHeart.SetActive(true);
        }
    }

    /// <summary>
    /// <para>Set all health points to the active state without changing their quantity</para>
    /// </summary>
    public void ResetHP()
    {
        ChangeHP(_hpCount);
    }

    /// <summary>
    /// <para>Add health point to current. If you want to subtract from the current state just add a negative number</para>
    /// </summary>
    /// <param name="value">Added value</param>
    public void AddHPToCurrent(int value)
    {
        int newHP = currentHP + value;
        ChangeHP(newHP);
    }

    private void ChangeHP(int newHP)
    {
        if (newHP > _hpCount || newHP < 0)
        {
            return;
        }

        bool activeState = newHP > currentHP;
        while (currentHP != newHP)
        {
            currentHP = activeState ? currentHP : currentHP - 1;
            hpImagesArray[currentHP].SetActive(activeState);
            currentHP = activeState ? currentHP + 1 : currentHP;
        }

        if (currentHP == 0)
        {
            OutOfHP?.Invoke();
        }
    }

    private UIHealthPoint SpawnHeart(int xOffset)
    {
        float fullXOffset = -xOffset * hpImageWidth - _prefabSpacing - hpImageWidth / 2;
        float fullYOffset = -hpImageHeight / 2;
        Vector3 spawnPosition = transform.position + new Vector3(fullXOffset, fullYOffset);

        UIHealthPoint spawnedUIHealthPoint =
            Instantiate(_uiHealthPointPrefab.gameObject, spawnPosition, Quaternion.Identity)
                .GetComponent<UIHealthPoint>();
        spawnedUIHealthPoint.transform.SetParent(transform);

        return spawnedUIHealthPoint;
    }
}
\end{minted}
\subsubsection*{UINumberParameterBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;

/// <summary>
/// <para>Class displays the value of a numeric parameter on the UI. Display format: "Parameter name: Value"</para>
/// </summary>
public class UINumberParameterBar : MonoBehaviour
{
    [SerializeField] private TMP_Text _text;
    [SerializeField] private string _parameterName;
    [Range(0, 6)] [SerializeField] private int _decimalPoint;

    [FormerlySerializedAs("_barVisability")] [FormerlySerializedAs("_showBar")] [SerializeField]
    private bool _barVisibility;

    /// <summary>
    /// <para>Parameter value displayed in UI each frame</para>
    /// </summary>
    protected float parameterValue = 0;

    protected virtual void Update()
    {
        if (_barVisibility)
        {
            _text.text = _parameterName + ": " + Math.Round(parameterValue, _decimalPoint);
        }
        else
        {
            _text.text = "";
        }
    }

    /// <summary>
    /// <para>Set bar visibility</para>
    /// </summary>
    /// <param name="visible">Is bar visible</param>
    public void SetVisible(bool visible)
    {
        _barVisibility = visible;
    }

    /// <summary>
    /// <para>Set showed parameter name</para>
    /// </summary>
    /// <param name="parameterName">The parameter name</param>
    public void SetParameterName(string parameterName)
    {
        _parameterName = parameterName;
    }

    /// <summary>
    /// <para>Set showed parameter value</para>
    /// </summary>
    /// <param name="parameterValue">The parameter value</param>
    public virtual void SetParameterValue(float parameterValue)
    {
        this.parameterValue = parameterValue;
    }

    /// <summary>
    /// <para>Set the color of the bar text</para>
    /// </summary>
    /// <param name="newColor">The new text color</param>
    public void SetColor(Color newColor)
    {
        _text.color = newColor;
    }
}
\end{minted}
\subsubsection*{UISmoothChangeNumberParameterBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using UnityEngine;

/// <summary>
/// <para>
///<inheritdoc cref="UINumberParameterBar"/>
/// If the value of a parameter has changed, the value on the UI will change from the previous value to the new value at the selected speed
/// </para>
/// </summary>
public class UISmoothChangeNumberParameterBar : UINumberParameterBar
{
    [Range(1, 1000)] [SerializeField] private int _changeParameterSpeed = 10;

    private float currentValue = 0;
    private float parameterSum;

    protected override void Update()
    {
        if (Math.Abs(currentValue - parameterValue) > 0)
        {
            parameterSum += Time.deltaTime * (currentValue - parameterValue) * _changeParameterSpeed;
            parameterValue = parameterSum;
        }

        base.Update();
    }

    /// <summary>
    /// <inheritdoc cref="UINumberParameterBar.SetParameterValue"/>
    /// </summary>
    /// <param name="parameterValue"><inheritdoc cref="UINumberParameterBar.SetParameterValue"/></param>
    public override void SetParameterValue(float parameterValue)
    {
        currentValue = parameterValue;
    }

    /// <summary>
    /// <para>Add number value current. If you want to subtract from the current value just add a negative number</para>
    /// </summary>
    /// <param name="addedValue">The added number value</param>
    public void AddValue(float addedValue)
    {
        parameterSum = parameterValue;
        currentValue += addedValue;
    }
}
\end{minted}
